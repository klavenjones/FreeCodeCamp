<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Tech Document</title>
    <link rel="stylesheet" href="/css/main.css">
</head>

<body>
    <div id="container">
        <nav id="navbar">
            <header>
                <h1>What is Node?</h1>
            </header>
            <a class="nav-link" href="#Introduction">Introduction</a>
            <a class="nav-link" href="#Global">Global</a>
            <a class="nav-link" href="#Modules">Modules</a>
            <a class="nav-link" href="#Why_Node">Why Node</a>
            <a class="nav-link" href="#How_To_Use_Node">How To Use Node</a>
            <a class="nav-link" href="#Node_As_a_REPL">Node As A REPL</a>
            <a class="nav-link" href="#Load_Existing_Files">Load Existing Files</a>
            <a class="nav-link" href="#Package_Management">Package Management</a>
            <a class="nav-link" href="#Node_Versions">Node Versions</a>
            <a class="nav-link" href="#Version_Management">Version Management</a>
        </nav>
        <main id="main-doc">
            <section class="main-section" id="Introduction">
                <header>
                    <h1>Introduction</h1>
                </header>
                <h2>
                    JAVASCRIPT AND NODE.JS
                </h2>
                <p>
                    Javascript has existed since 1995 and has since taken over as the dominant language for web
                    development.
                    For much of its life, JavaScript was used mainly for client-side scripting inside <code>&lt;script&gt;</code>
                    tags executing in web browsers.
                    This limitation meant that developers were often working in many different languages and frameworks
                    between the front-end (client-side) and backend (server-side)
                    aspects of a web application.
                </p>
                <p>
                    Although there were other projects to bring JavaScript to server-side applications, the
                    functionality took off with the launch of Node.js in 2009.
                    Node allows developers to write JavaScript code that runs directly in a computer process itself
                    instead of in a browser.
                    Node can, therefore, be used to write server-side applications with access to the operating system,
                    file system, and everything else required to build fully-functional applications.
                </p>
                <p>
                    Node.js is written in C, C++, and JavaScript, and it is built on the open-source V8 JavaScript
                    engine which also powers JS in browsers such as Google Chrome. As V8 supports new features in
                    JavaScript, they are incorporated into Node.
                </p>
            </section>
            <section class="main-section" id="Global">
                <header>
                    <h1>Global</h1>
                </header>

                <p>
                    Node provides access to several important global objects for use with Node program files. When
                    writing a file that will run in a Node environment, these variables will be accessible in the
                    global scope of your file.
                </p>
                <ul>
                    <li><code>module</code> is an object referring to the functionality that will be exported from a
                        file. In Node, each file is treated as a module.</li>
                    <li><code>require()</code> is a function used to import modules from other files or Node packages.</li>
                    <li><code>process</code> is an object referencing to the actual computer <a href="https://en.wikipedia.org/wiki/Process_(computing)">process</a>
                        running a Node program and allows for access to command-line arguments and much more.</li>
                </ul>

            </section>
            <section class="main-section" id="Modules">
                <header>
                    <h1>Modules</h1>
                </header>
                <p>
                    Node has a many built-in modules to aid in interactions with the command line, the computer file
                    system, and the Internet.
                    These include
                </p>
                <ul>
                    <li><a href="https://nodejs.org/dist/latest/docs/api/http.html">HTTP</a> and <a href="https://nodejs.org/dist/latest/docs/api/https.html">HTTPS</a>
                        for creating web servers.</li>
                    <li><a href="https://nodejs.org/dist/latest/docs/api/fs.html">File System</a>, <a href="https://nodejs.org/dist/latest/docs/api/os.html">OS</a>,
                        and <a href="https://nodejs.org/dist/latest/docs/api/path.html">Path</a> for interacting with
                        the file system, operating system, and file/directory paths.</li>
                </ul>
                <p>You can view the full <a href="https://nodejs.org/dist/latest/docs/api/" target="_blank">docs</a> to
                    see more of Node's built-in features.</p>
            </section>
            <section class="main-section" id="Why_Node">
                <header>
                    <h1>
                        Why Node
                    </h1>
                </header>
                <p>Per the <a href="https://nodejs.org/">Node.js homepage</a>, Node "uses an event-driven, non-blocking
                    I/O model." In practice, this means that Node is built well to handle asynchronous JavaScript code
                    to perform many asynchronous activities such as reading and writing to the file system, handling
                    connections to database servers, or handling requests as a web server.</p>
                <p>
                    To handle asynchronous code, Node uses a callback-based system. Node functions and methods that
                    will
                    implement some asynchronous activity take a callback function. This callback will be called
                    whenever the asynchronous operation has resolved. By convention, the first argument of this
                    callback is an error placeholder. If an error occurred in the asynchronous operation occurred
                    (trying to read a non-existent file, for example), the error argument will be an Error object, but
                    it will be <code>null</code> if no error occurs.
                </p>
                <!-- THIS IS A MESS BEWARE! I TRIED TO REPLICATE THE FORMAT OF JS -->
                <div class="markdown">
                    <code>
                            <span class="js-purple">const fs</span>  = <span class="js-orange">require</span>( <span class="js-yellow">'fs'</span>);
                            
                            <span class="js-orange">fs</span>.<span class="js-teal">readFile</span>(<span class="js-yellow">'./script.js'</span>, <span class="js-purple">function</span>(<span class="js-purple">error</span>,<span class="js-purple"> data</span>){
                                &nbsp;<span class="js-comment">// error is null if no error occurred, but an Error object if it did</span>
                               
                               &nbsp; <span class="js-purple">if</span> (<span class="js-orange">error</span>) {
                                &nbsp;  &nbsp; <span class="js-purple">throw</span> <span class="js-orange">error</span>;
                                &nbsp; }
                                &nbsp;<span class="js-comment">// the file data will be passed into the callback if no error was thrown</span>
                                &nbsp;  <span class="js-orange">console</span>.<span class="js-purple">log</span>(<span class="js-orange">data</span>);
                            });
                    </code>
                </div>

                <p>
                    In this example, we are using Node's built-in <code>fs</code> module to read a <em>script.js</em>
                    file. The callback function is called after the file-reading operation is completed. If an
                    error occurred, it will be passed in as <code>error</code> and thrown. If it doesnâ€™t exist, the
                    retrieved data from the file reading operation is logged to the console.
                </p>

            </section>
            <section class="main-section" id="How_To_Use_Node">
                <header>
                    <h1>How To Use Node</h1>
                </header>
                <p>This video will show you how to download and install Node.</p>
                <video width="100%" height="100%" controls="" onloadstart="this.volume=0.15">
                    <source src="https://s3.amazonaws.com/codecademy-content/articles/nodejs/nodejs.mp4" type="video/mp4">
                    The markdown processor does not support the video tag.
                </video>
                <p>To begin, <a href="https://nodejs.org/en/download/" target="_blank">download</a> and install Node.js
                    for your operating system.</p>
                <p>To run JS files in Node, the <code>node</code> command followed by a file path will execute the
                    program file.</p>
                <p>For example, if we have the following saved in a file <em>script.js</em>:</p>
                <div class="markdown">

                    <code>
                        <span class="js-orange">console</span>.<span class="js-purple">log</span>(<span class="js-yellow">"I am a Node program!"</span>);
                    </code>

                </div>
                <p>Running the terminal command <code>node script.js</code> in the same folder as <em>script.js</em>
                    will start Node, print <code>I am a Node program</code> to the terminal window, and exit, as the
                    script file has finished execution.</p>
            </section>
            <section class="main-section" id="Node_As_a_REPL">
                <header>
                    <h1>Node As a REPL</h1>
                </header>
                <p>Node can also be used in a terminal window as a Read-Evaluate-Print-Loop, or REPL. This
                    functionality allows you execute JavaScript commands from the command line. </p>
                <p>With Node installed, you can launch the REPL by running the <code>node</code> command in a terminal
                    and pressing Enter/Return. You are now in an interactive JavaScript environment and can run any
                    valid JavaScript code such as <code>4 + 5</code>. After executing a command, Node will always print
                    the result of that evaluation.</p>

                <div class="markdown">
                    <code>
                        $ node
                        &gt; 4 + 5
                        9
                        &gt; function nodeIsGreat() {
                        ... console.log('Node is great!');
                        ... }
                        undefined
                        &gt; nodeIsGreat()
                        Node is great!
                        undefined
                        &gt; .exit
                        $
                    </code>
                </div>
                <p>In this example, the user launches node on line one with the <code>node</code> terminal command.
                    On line 2 the user types <code>4 + 5</code> and evaluates with the return key. <code>9</code>
                    prints to the output terminal.</p>
                <p>On line 4, the user opens a function declaration of <code>nodeIsGreat</code>. Because this
                    function declaration takes multiple lines, Node REPL will print <code>...</code> at the
                    beginning of a line to show that it is still reading the user's input statement and has not
                    evaluated yet. After the function declaration is closed on line 6, <code>undefined</code>
                    prints to the output terminal, as the function declaration itself does not evaluate to any
                    value. When the function is invoked on line 8, <code>Node is great!</code> logs to the console,
                    and <code>undefined</code> logs after, because <code>nodeIsGreat()</code> returns <code>undefined</code>.</p>
                <p>To exit the Node REPL, use the <code>.exit</code> command at any point and return to the system
                    shell. Pressing <code>ctrl + c</code> twice will also exit. </p>

            </section>
            <section class="main-section" id="Load_Existing_Files">
                <header>
                    <h1>Load Existing Files</h1>
                </header>
                <p>Node REPL can also load existing JS files. If we had the following code saved into <em>script.js</em>:</p>
                <div class="markdown">

                    <code>
                            <span class="js-purple">var a</span> = <span class="js-yellow">'Node REPL is fun!'</span>;
                    </code>

                </div>
                <p>
                    We can use <code>.load</code> to load it into the REPL. <code>.load</code> takes a path argument,
                    so
                    to load <em>script.js</em> we would use <code>.load ./script.js</code>.
                </p>
                <div class="markdown">
                    <code>
                        $ node
                        > .load ./script.js
                        var a = 'Node REPL is fun!';
                        
                        > a
                        'Node REPL is fun!'
                    </code>
                </div>
                <p>After the script file is loaded, the variables are accessible in the REPL, so when we evaluate
                    the <code>a</code> variable, it's value has been set by loading <em>script.js</em>, and 'Node
                    REPL is fun!' prints to the console.</p>
                <p>Try it out yourself by running <code>node</code> in a terminal or check out the <a href="https://nodejs.org/api/repl.html">REPL
                        docs</a> for more functionality.</p>


            </section>
            <section class="main-section" id="Package_Management">
                <header>
                    <h1>
                        Package Management
                    </h1>
                </header>
                <p>Node packages are a convenient way to share modules between Node developers. The service <a href="https://www.npmjs.com/">npm</a>
                    is the default package manager for Node, and it ships with an installation of Node.</p>
                <p>npm allows access to the hundreds of thousands of open-source packages available.</p>
                <p>In addition to npm, <a href="https://yarnpkg.com/en/">yarn</a> is gaining popularity as another JS
                    package manager.</p>
                <p>For more information and to see npm in action take our <a href="https://www.codecademy.com/courses/learn-javascript-transpilation/lessons/browser-compatibility-and-transpilation/exercises/browser-compatibility-introduction">Browser
                        Compatibility and Transpilation</a> course.</p>
            </section>
            <section class="main-section" id="Node_Versions">
                <header>
                    <h1>Node Versions</h1>
                </header>
                <p>Node's major releases aim to support the latest JavaScript features including ES6/ES2015 and beyond
                    without transpilation.</p>
                <p>To see a list of supported JavaScript features in different versions, visit <a href="http://node.green/">node.green</a></p>
            </section>
            <section class="main-section" id="Version_Management">
                <header>
                    <h1>Version Management</h1>
                </header>
                <p>As with any major release of software, top-level Node releases (8.x, 7x, etc.) sometimes introduce
                    breaking changes in applications built in older versions of the environment. A version manager can
                    be used to switch between multiple versions of Node on a single computer.</p>
                <p>There are two version managers that provide this functionality: <a href="https://github.com/creationix/nvm">nvm
                        (Node Version Manager)</a> and <a href="https://github.com/tj/n">n</a>. N can be installed very
                    easily as an npm package!</p>
            </section>
            <h1>
                Reference
            </h1>
            <p>All Documentation on this page was taken from this <a href="https://www.codecademy.com/articles/what-is-node">article</a>.</p>
        </main>

    </div>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</body>

</html>